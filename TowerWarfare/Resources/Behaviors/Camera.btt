{"Name":null,"FilePath":null,"RootNode":{"Arguments":[],"NodeType":4,"Children":[{"Arguments":[{"Value":0.02,"Type":"System.Single, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e"},{"Value":0.001,"Type":"System.Single, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e"},{"Value":1.0,"Type":"System.Single, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e"}],"NodeType":7,"Children":[],"InlineCondition":null,"InlineAction":null,"LeafType":null,"Script":{"Name":"CameraNode","Contents":"using SpiceEngine.GLFWBindings.Inputs;\r\nusing SpiceEngineCore.Entities.Cameras;\r\nusing SpiceEngineCore.Geometry;\r\nusing SpiceEngineCore.Utilities;\r\nusing System;\r\nusing TangyHIDCore;\r\nusing UmamiScriptingCore;\r\nusing UmamiScriptingCore.Behaviors;\r\nusing UmamiScriptingCore.Behaviors.Nodes;\r\n\r\nnamespace TowerWarfare.Resources.Behaviors.Nodes\r\n{\r\n    public class CameraNode : Node\r\n    {\r\n        public const float STRAFE_SCALE = 0.002f;\r\n        public const float TRAVEL_SCALE = 0.02f;\r\n        public const float TURN_SCALE = 0.001f;\r\n        public const float ZOOM_SCALE = 0.1f;\r\n\r\n        public const float MIN_ZOOM_POSITION = 10.0f;\r\n        public const float MAX_ZOOM_POSITION = 100.0f;\r\n\r\n        private float _yaw; // Yaw of zero should point in the direction of the X-Axis\r\n        private float _pitch; // Pitch of zero should point in the direction of the X-Axis\r\n\r\n        public CameraNode(float moveSpeed, float turnSpeed, float zoomSpeed)\r\n        {\r\n            MoveSpeed = moveSpeed;\r\n            TurnSpeed = turnSpeed;\r\n            ZoomSpeed = zoomSpeed;\r\n\r\n            _yaw = MathExtensions.HALF_PI;\r\n            _pitch = -MathExtensions.HALF_PI + 0.01f;\r\n        }\r\n\r\n        public float MoveSpeed { get; set; } //= 0.02f;\r\n        public float TurnSpeed { get; set; } //= 0.001f;\r\n        public float ZoomSpeed { get; set; } //= 1.0f;\r\n\r\n        public override BehaviorStatus Tick(BehaviorContext context)\r\n        {\r\n            if (context.GetEntity() is PerspectiveCamera camera)\r\n            {\r\n                var inputProvider = context.SystemProvider.GetGameSystem<IInputProvider>();\r\n\r\n                if (inputProvider.IsDown(MouseButtons.Right))\r\n                {\r\n                    Strafe(camera, inputProvider.MouseDelta);\r\n                }\r\n                \r\n                if (inputProvider.IsMouseInWindow && inputProvider.MouseWheelDelta != 0)\r\n                {\r\n                    Zoom(camera, inputProvider.MouseWheelDelta);\r\n                }\r\n\r\n                if (inputProvider.IsDown(MouseButtons.Button1))\r\n                {\r\n                    Travel(camera, inputProvider.MouseDelta);\r\n                }\r\n\r\n                if (inputProvider.IsDown(MouseButtons.Button2))\r\n                {\r\n                    Turn(camera, inputProvider.MouseDelta);\r\n                }\r\n            }\r\n\r\n            return BehaviorStatus.Success;\r\n        }\r\n\r\n        public override void Reset() { }\r\n\r\n        public void Strafe(PerspectiveCamera camera, Vector2 mouseDelta)\r\n        {\r\n            if (mouseDelta != Vector2.Zero)\r\n            {\r\n                var upDirection = camera.Up;\r\n                var lookDirection = camera.LookAt - camera.Position;\r\n\r\n                var rightDirection = Vector3.Cross(upDirection, lookDirection).Normalized();\r\n\r\n                // TODO - Improve this calculation, it should not just be using the raw Z position as a scalar\r\n                var verticalTranslation = upDirection * mouseDelta.Y * TRAVEL_SCALE;//STRAFE_SCALE * camera.Position.Z;\r\n                var horizontalTranslation = rightDirection * mouseDelta.X * TRAVEL_SCALE;//STRAFE_SCALE * camera.Position.Z;\r\n\r\n                camera.Position += verticalTranslation + horizontalTranslation;\r\n                camera.LookAt += verticalTranslation + horizontalTranslation;\r\n            }\r\n        }\r\n\r\n        public void Zoom(PerspectiveCamera camera, int mouseWheelDelta)\r\n        {\r\n            var translation = (camera.LookAt - camera.Position) * mouseWheelDelta * ZOOM_SCALE;\r\n\r\n            camera.Position = new Vector3()\r\n            {\r\n                X = camera.Position.X - translation.X,\r\n                Y = camera.Position.Y - translation.Y,\r\n                Z = (camera.Position.Z - translation.Z).Clamp(MIN_ZOOM_POSITION, MAX_ZOOM_POSITION)\r\n            };\r\n        }\r\n\r\n        public void Travel(PerspectiveCamera camera, Vector2 mouseDelta)\r\n        {\r\n            if (mouseDelta != Vector2.Zero)\r\n            {\r\n                var translation = (camera.LookAt - camera.Position) * mouseDelta.Y * TRAVEL_SCALE;\r\n                camera.Position -= translation;\r\n\r\n                _yaw = (_yaw - mouseDelta.X * TURN_SCALE) % MathExtensions.TWO_PI;\r\n                CalculateLookAt(camera);\r\n                CalculateUp(camera);\r\n            }\r\n        }\r\n\r\n        public void Turn(PerspectiveCamera camera, Vector2 mouseDelta)\r\n        {\r\n            if (mouseDelta != Vector2.Zero)\r\n            {\r\n                _yaw = (_yaw - mouseDelta.X * 0.001f) % MathExtensions.TWO_PI;\r\n                _pitch -= mouseDelta.Y * TURN_SCALE;\r\n                _pitch = _pitch.Clamp(-MathExtensions.HALF_PI, MathExtensions.HALF_PI);\r\n\r\n                CalculateLookAt(camera);\r\n                CalculateUp(camera);\r\n            }\r\n        }\r\n\r\n        private void CalculateLookAt(PerspectiveCamera camera)\r\n        {\r\n            var lookDirection = new Vector3()\r\n            {\r\n                X = (float)(Math.Cos(_yaw) * Math.Cos(_pitch)),\r\n                Y = (float)(Math.Sin(_yaw) * Math.Cos(_pitch)),\r\n                Z = (float)Math.Sin(_pitch)\r\n            };\r\n\r\n            camera.LookAt = camera.Position + lookDirection.Normalized();\r\n        }\r\n\r\n        private void CalculateUp(PerspectiveCamera camera)\r\n        {\r\n            var yAngle = _pitch + MathExtensions.HALF_PI;\r\n\r\n            var upDirection = new Vector3()\r\n            {\r\n                X = (float)(Math.Cos(_yaw) * Math.Cos(yAngle)),\r\n                Y = (float)(Math.Sin(_yaw) * Math.Cos(yAngle)),\r\n                Z = (float)Math.Sin(yAngle)\r\n            };\r\n\r\n            camera.Up = upDirection.Normalized();\r\n        }\r\n    }\r\n}\r\n"}}],"InlineCondition":null,"InlineAction":null,"LeafType":null,"Script":null},"Responses":[]}